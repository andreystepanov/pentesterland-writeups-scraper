import axios from 'axios'
import cheerio from 'cheerio'
import moment from 'moment'
import filter from 'lodash/filter'
import sortBy from 'lodash/sortBy'

const URL = 'https://pentester.land/list-of-bug-bounty-writeups.html'

const format = ({ data: source }) => {
  const $ = cheerio.load(source)
  const data = {}

  const parse = (table, collection) => {
    let list = []

    const items = table.find('tbody tr').map((i, el) => {
      let rows = $(el).find('td')
      let brokenHtml = false
      const item = {}
      const names = [
        'title',
        'hackers',
        'programs',
        'weaknesses',
        'bounty',
        'published_at',
      ]

      if (rows.length < 6) {
        rows.eq(1).clone().insertAfter(rows.eq(1))
        rows = $(el).find('td')
      }

      rows.map((i, el) => {
        if (i > 5) {
          return
        }

        let field = names[i]
        const element = $(el)
        let value = element.text()

        switch (field) {
          case 'title':
            item['url'] = element.find('a').attr('href') || null
            break
          case 'weaknesses':
            value = value ? value.split(',') : null
            break
          case 'programs':
            const matches = value.match(/<td(.*)>(.*)$/g)

            if (matches) {
              value = matches[0].split('>').pop()
            }

            if (value) {
              value = value.split(',')
            }

            break
          case 'hackers':
            const links = element.contents()

            if (links) {
              value = []

              links.map((i, el) => {
                const link = $(el)
                const href = link.attr('href') || null
                const name = link.text()
                const hacker = {
                  name: name
                    .replace(/\//g, '')
                    .replace(/(\(.*\)([\s\S]+)?)/g, '')
                    .trim(),
                }

                if (href) {
                  if (href.includes('twitter.com')) {
                    hacker.twitter_handle = href.split('/').pop()
                  } else {
                    hacker.website = href
                  }
                }

                if (
                  name.includes('<td markdown') === false &&
                  /[.,&]/.test(name) === false
                ) {
                  value.push(hacker)
                }
              })
            }

            break
          case 'published_at':
            if (
              !(value && value.split('/').length === 3 && value.length >= 10)
            ) {
              value = null
              break
            }

            const date = moment(value.replace(/[^\d\/]/g, ''), 'MM/DD/YYYY')

            if (date.isValid()) {
              item.published = {
                year: date.format('YYYY'),
                month: date.format('MM'),
                day: date.format('DD'),
              }

              value = date.format('YYYY-MM-DD')
            }

            break
          case 'bounty':
            if (value && /.*\d{2}\/\d{2}\/\d{4}.*/.test(value)) {
              // console.log('Date instead of bounty')
              value = null
              break
            }

            const str = value.toLowerCase()

            if (str.includes('swag')) {
              item.swag = true
            }

            if (
              str.includes('informative') ||
              str.includes('wonâ€™t fix') ||
              str.includes('wontfix') ||
              str.includes('feature')
            ) {
              item.status = 'informative'
            }

            if (str.includes('oos') || str.includes('out of')) {
              item.status = 'out_of_scope'
            }

            if (str.includes('n/a')) {
              item.status = 'not_applicable'
            }

            if (str.includes('duplicate')) {
              item.status = `duplicate`
            }

            if (str.includes('vdp')) {
              item.vdp = true
            }

            if (str.includes('hof')) {
              item.hall_of_fame = true
            }

            const pattern = /[^S]?\$(\d+([.]{1}\d{1,2})?)/
            const numbers = value.replace(/[,]/g, '').match(pattern)
            const bounty =
              numbers && numbers.length >= 2 ? parseFloat(numbers[1]) : null

            // if (item.title.includes('Should this be public though?')) {
            // console.log(value)
            // console.log(numbers)
            // }

            value = isNaN(bounty) ? null : bounty

            break
        }

        if (item[field]) {
          value = item[field]
        }

        value = typeof value === 'string' ? value.trim() : value

        if (Array.isArray(value)) {
          value = value
            .map(item => (typeof item === 'string' ? item.trim() : item))
            .filter(item => item && item !== '-')

          if (value.length < 1) {
            value = null
          }
        }

        item[field] = value === '-' ? null : value
      })

      if (Object.keys(item).length > 0) {
        list.push(item)
      }
    })

    if (collection && collection !== 'unknown') {
      list = sortBy(list, 'published_at').reverse()
    }

    return list
  }

  $('h2[id^=bug-bounty-writeups-]').map((i, el) => {
    const h2 = $(el)
    const id = h2.attr('id')
    const collection = id.includes('unknown') ? 'unknown' : id.split('-').pop()
    const table = h2.next('table')

    data[collection] = table ? parse(table, collection) : []
  })

  return data
}

const load = async ({
  bounty = false,
  year,
  month,
  order = 'desc',
  group = false,
  title,
} = {}) => {
  const unknown = year && year === 'unknown'
  const data = await axios
    .get(URL, {
      headers: {
        'User-Agent': 'pentesterland-writeups-scraper/0.1',
      },
    })
    .then(format)
  let list = []

  if (group) {
    return data
  }

  if (unknown) {
    list = data.unknown
  } else if (year) {
    if (!data[year]) {
      return []
    }

    list = data[year]

    if (month) {
      list = filter(list, { published: { month } })
    }
  } else {
    list = list.concat(...Object.values(data))
  }

  // list = sortBy(list, 'published_at')
  list = list.sort((a, b) => {
    if (a.published && b.published) {
      return moment(a.published_at).unix() - moment(b.published_at).unix()
    }

    return -1
  })

  if (order === 'desc') {
    list = list.reverse()
  }

  if (title && typeof title === 'string') {
    list = list.filter(item =>
      item.title.toLowerCase().includes(title.toLowerCase()),
    )
  }

  return list
}

export default load
